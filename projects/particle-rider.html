<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>HTML5 Particle Rider by Thomas Reynolds</title>
</head>
<body>

<canvas id="myCanvas" resize></canvas><style>
  body {
    margin: 0;
    padding: 0;
  }
</style>
<script src="particle-rider/javascripts/paper.js"></script><script type="text/paperscript" canvas="myCanvas">
  var path = new Path();
  path.add(view.center);
  path.selected = true;
  var particles = [];
  
  for (var i = 0; i < 50; i++) {
    var randomX = (Math.random() * view.width) - (view.width/2);
    var randomY = (Math.random() * 100.0) - 50.0;
    
    var point = new Point(
      randomX,
      randomY
    )
    var targetPoint = view.center + (Size.random() * view.size) - (view.size/2);
    
    var randomSize = (Math.random() * 11.0) + 2.0;
    var circle = new Path.Circle(targetPoint, randomSize);
    circle.fillColor = new HsbColor(Math.random() * 360, 1, 1);
    circle.strokeColor = "black";
    circle.strokeWidth = 1;
    // circle.blendMode = i % 2 ? 'screen' : 'multiply';
    
    particles.push({
      view: circle,
      acceleration: new Point({ x: 0, y: 0 }),
      velocity:     new Point({ x: 0, y: 0 }),
      speed:        0.01 + Math.random() * 0.05,
      target:       targetPoint,
      offset:       ((Point.random() * 100.0) - 50.0)
    });
  }
  
  var debugPaths = [];
  function onFrame(event) {
    for (var k = 0; k < debugPaths.length; k++) {
      debugPaths[k].remove();
      debugPaths[k] = null;
    }
    debugPaths = [];
    
    for (var i = 0; i < particles.length; i++) {
      var particle = particles[i];
      
      var direction = particle.view.position;
      var distances = [];
      var data = [];
      data.push(direction.x);
      
      var nearestIndex = null;
      var nearestDist = Infinity;
      
      for (var j = 0; j < path.segments.length; j++) {
        var segment = path.segments[j];
        var distance = segment.getPoint().getDistance(particle.view.position);
        if (distance < nearestDist) {
          nearestDist = distance;
          nearestIndex = j;
        }
      }
      
      if (nearestDist > 200) {
        continue;
      }
      
      if (nearestIndex !== null) {
        var nearestPoint = path.segments[nearestIndex].getPoint();
        
        // var debugPath = new Path();
        // debugPath.add(particle.view.position);
        // debugPath.add(nearestPoint);
        // debugPath.strokeColor = "blue";
        // debugPath.strokeWidth = 2;
        // debugPaths.push(debugPath);
        direction += nearestPoint - particle.view.position;
        
        var nextPoint;
        if (nearestIndex < path.segments.length-1){
          nextPoint = path.segments[nearestIndex+1].getPoint();
          
          // var debugPath = new Path();
          // debugPath.add(particle.view.position);
          // debugPath.add(nextPoint);
          // debugPath.strokeColor = "green";
          // debugPath.strokeWidth = 2;
          // debugPaths.push(debugPath);
          direction += (nextPoint - particle.view.position) * 2;
        }
        
        if (nearestIndex+1 < path.segments.length-1){
          nextPoint = path.segments[nearestIndex+2].getPoint();
          
          // var debugPath = new Path();
          // debugPath.add(particle.view.position);
          // debugPath.add(nextPoint);
          // debugPath.strokeColor = "green";
          // debugPath.strokeWidth = 2;
          // debugPaths.push(debugPath);
          direction += (nextPoint - particle.view.position) * 3;
        }
        
        if (nearestIndex+2 < path.segments.length-1){
          nextPoint = path.segments[nearestIndex+3].getPoint();
          
          // var debugPath = new Path();
          // debugPath.add(particle.view.position);
          // debugPath.add(nextPoint);
          // debugPath.strokeColor = "green";
          // debugPath.strokeWidth = 2;
          // debugPaths.push(debugPath);
          direction += (nextPoint - particle.view.position) * 4;
        }
      }
      
      // var debugPath = new Path();
      // debugPath.add(particle.view.position);
      // debugPath.add(direction);
      // debugPath.strokeColor = "red";
      // debugPath.strokeWidth = 2;
      // debugPaths.push(debugPath);
      
      particle.view.position += (direction + particle.offset - particle.view.position) * (particle.speed);
    }
  }
  
  tool.fixedDistance = 30;
  function onMouseMove(event) {
    path.add(event.point);
    
    if (path.segments.length > 50) {
      path.removeSegment(0);
    }
    
    path.smooth();
    
    for (var i = 0; i < particles.length; i++) {
      var particle = particles[i];
      // var diffVec  = (event.point - particle.view.position).normalize();
      // console.debug(diffVec.x, diffVec.y);
      // particle.velocity += diffVec;
      // particle.target = event.point + ((Point.random() * 20.0) - 10.0);
      // console.debug(particle.velocity.x, particle.velocity.y);
      // 
      // particle.acceleration += diffVec;
      // var nearest = path.getNearestPoint(particle.view.position);
      // particle.target = nearest;
      // console.debug(nearest.x, nearest.y)
      // console.debug("p", particle.view.position.x, particle.view.position.y);
      var direction = particle.view.position;
      var distances = [];
      for (var j = 0; j < path.segments.length; j++) {
        var segment = path.segments[j];
      }
    }
  }
  
</script>
</body>
</html>
